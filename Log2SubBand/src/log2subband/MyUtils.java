/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package log2subband;

import com.opencsv.CSVReader;
import com.opencsv.CSVWriter;
import java.awt.Desktop;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.logging.Level;
import java.util.logging.Logger;
import static log2subband.HuffmanCode.number_to_encoding_dict;
import static log2subband.Log2SubBand.debug;
import static log2subband.Log2SubBand.parameters;

/**
 *
 * @author Jakub
 */
public class MyUtils {
        
    /**
     * Splits String composed of values separated by comma into array, removing all spaces
     * @param str_input Comma separated string of values
     * e.g. "12, 21, 12, 43 " => ["12", "21", "12", "43"]
     * @return Array obtained by separating commas in string and removing extra spaces
     */
    public static String[] CSstring_to_array(String str_input) {
        return str_input.split(",[ ]*");
    }

    /**
     * Attempts to parse a CSV file.
     * !!! Currently no check if file is a valid csv file
     * @param file_path Path to a file to parse
     * @return String[] of data from a file
     */
    public static String[] parse_CSV (String file_path){
        CSVReader reader = null;
        try {reader = new CSVReader(new FileReader(file_path));}
        catch (FileNotFoundException ex) {Logger.getLogger(Log2SubBand.class.getName()).log(Level.SEVERE, null, ex);} // autogenerated
        String[] data_parsed = null;
        if (reader instanceof CSVReader) {
            String comma_sep_values = "";
            try {List<String[]> my_data = reader.readAll();
                try {
                    for (String[] line : my_data) {
                        for (String value : line) {
                            if (value.length() > 0) comma_sep_values += value + ",";
                        }
                    }
                    comma_sep_values = comma_sep_values.substring(0, comma_sep_values.length()-1); // remove last comma
                    data_parsed = CSstring_to_array(comma_sep_values);
                    
                    if(debug) System.out.println(comma_sep_values);
                } catch (IndexOutOfBoundsException e) {} // No info about size, need to try and read until we get too far         
            }
            catch (IOException ex) {Logger.getLogger(Log2SubBand.class.getName()).log(Level.SEVERE, null, ex);}  // autogenerated   
        }
        return data_parsed;
    }

   /**
    * Creates/overwrites a CSV file with name <code>filename</code>.csv and writes inputted data to it
    * Newlines are achieved by using \n.
    * WARNING Overwrites existing files !!!
    * @param filename Name of file to create/overwrite
    * @param data String array of data to write to file
    */
    public static void write_CSV(String filename, String[] data) {
        CSVWriter writer;
        try {
            writer = new CSVWriter(new FileWriter(filename + ".csv"), ',', CSVWriter.NO_ESCAPE_CHARACTER);
            writer.writeNext(data);
            writer.close();
        System.out.print("File successfully created\n");
        } catch (IOException ex) {
            Logger.getLogger(MyUtils.class.getName()).log(Level.SEVERE, null, ex);
            System.out.print("Something went wrong. File not created\n");
        }
    }

    /**
     * Launches a file given its path
     * If file in current directory, filename is sufficient
     * @param filepath
     */
    public static void open_file(String filepath) {
    File f = new File(filepath);
        try {Desktop.getDesktop().open(f);} catch (IOException e) {System.out.println("ERROR, Can't open file.");}
    }

    /**
     * Creates CSV table outlining original and encoded values of strings using
       <code>original</code> and <code>encoded</code>
     * <br> Uses <code>number_to_encoding_dict</code> as mapping of numbers and their respective Huffman codes
     * @param original array of original data
     * @param encoded array of encoded data
     * @param binary_input array of original data in binary
     * @return String[] of CSV table data
     */
    public static String[] make_export_table(String[] original, String[] encoded, String[] binary_input) {
        String result_string = "Original(dec)," + append_spaces("Original(bin),", 14) + append_spaces("Encoded", 14) + ",Huffman*";
        for (int i=0; i<original.length; i++) {
            String crap = binary_to_decimal(original[i]);
            result_string += "\n" + append_spaces(crap, 13) + "," + append_spaces(original[i], 13) + "," + append_spaces(encoded[i],14);
            result_string += "," + get_huffman_encoding(original[i]);
        }
        String[] result = result_string.split(",");
        return result;
    }

    /**
     * After <code>init_ideal_huffman_dictionaries(String string_to_encode) </code> is run,
       this method can be used to return Huffman encoding of <code>to_encode</code>
       as a concatenation of Huffman encodings of all symbols (characters) in <code>to_encode</code>
       using <code>number_to_encoding_dict</code> (Mapping of numbers and their respective Huffman codes)
     * @param to_encode String to get Huffman encoding of
     * @return Concatenation of Huffman encodings of all symbols (characters) in <code>to_encode</code>
     */
    public static String get_huffman_encoding(String to_encode) {
        if(debug) System.out.println("INITIAL TO ENCODE: " + to_encode);
        to_encode = binary_to_decimal(binary_to_12_bits(to_encode));//binary_to_decimal(String.valueOf(transformed));
        if(debug) System.out.println("DECIMAL TO ENCODE: " + to_encode);
        to_encode = String.valueOf(Integer.valueOf(to_encode) + HuffmanCode.HUFFMAN_ADDITION);
        if(debug) System.out.println("TRANSFORMED TO ENCODE: " + to_encode);
        String result = number_to_encoding_dict.get(to_encode);
        if(debug) System.out.println("ENCODED INTO :" + result);
        if (result == null) throw new NoSuchElementException("Codebook ERROR, no encoding found for '" + to_encode + "'");
        return result;
    }

    /**
     * Formatting method that appends spaces to <code>input</code> to achieve
       desired length of <code>input</code>
     * Only works when <code>desired_length > input</code>
     * @param input original string
     * @param desired_length length of desired string
     * @return Original string with appended spaces based on original and desired length
     */
    public static String append_spaces(String input, int desired_length) {
        return String.format("%" + (-desired_length) + "s", input);
    }

    /**
     * Splits <code>input</code> string into substrings of length <code>length</code>
     * @param input
     * @param length
     * @return String[] of substrings of original string
     */
    public static String[] split_by_length (String input, int length) {
        return input.split("(?<=\\G.{" + length + "})"); //http://stackoverflow.com/questions/3760152/split-string-to-equal-length-substrings-in-java
    }

    public static Double compression_rate(String overall_compressed, String overall_uncompressed) {
        return Math.round(100.0 * overall_uncompressed.length()/overall_compressed.length())/100.0;
    }

    /**
     * Prints compression results
     * @param input_string original string to encode
     * @param overall_compressed full compressed string [1,0]*
     * @param overall_uncompressed original string compressed and then decompressed (ideally same as input string)
     */
    public static void print_log2subband_compression_results(String input_string, String overall_compressed, String overall_uncompressed) {
        System.out.println("Input:   " + input_string);
        System.out.println("Compressed data:   " + overall_compressed);
        System.out.println("Total compressed length = " + overall_compressed.length());
        System.out.println("Uncompressed data: " + overall_uncompressed);
        System.out.println("Total uncompressed length = " + overall_uncompressed.length());
        double compression_rate = compression_rate(overall_compressed, overall_uncompressed);
        System.out.println("Log2SubBand Original/Compressed: " + compression_rate);
        System.out.println("Decompressed data: " + Log2SubBand.log2_sub_band_decode_string(overall_compressed));
    }

    /**
     * Compresses input array of numbers, saving data through the process
     * @param raw_values String[] of numbers to compress
     * @return Map<String, String> to_return  (almost like an associative array), to get values:
     *  <br><b>to_return.get("overall_compressed");</b> Binary concatenated string of all compressed values in given array
        <br><b>to_return.get("overall_uncompressed");</b> Binary concatenated string of all compressed values in given array
        <br><b>to_return.get("input");</b> Comma separated String of values in inputted <code>raw_values</code>
        <br><b>to_return.get("output");</b> Comma separated String of compressed values (i.e. overall_compressed with commas in between)
     */
    public static Map<String, String> perform_log2_sub_band_compression(String[] raw_values) {
        String ovrl_compr, ovrl_uncompr, input, output;
        ovrl_compr = ovrl_uncompr = input = output = "";

        for (String raw_value : raw_values) {
            raw_value = decimal_to_binary(raw_value);
            input += "," + raw_value;

            String current_compressed = Log2SubBand.log2_sub_band_compress_number(raw_value);
            ovrl_compr += current_compressed;
            output += "," + current_compressed;
            if (debug) System.out.println("Current compressed data: " + current_compressed);
            ovrl_uncompr += raw_value;
        }

        Map<String, String> to_return = new HashMap<>();
        to_return.put("overall_compressed", ovrl_compr);
        to_return.put("overall_uncompressed", ovrl_uncompr);
        to_return.put("input", input.substring(1));
        to_return.put("output", output.substring(1));

        return to_return;
    }

    /**
     * Given parsed codebook data, escapes first 2 values (assumed to be column names). and assuming that
     * <br>Every alternating number (1st, 3rd, 5th...) is number for codebook
     * <br>Every alternating number (2nd, 4th, 6th...) is encoding for codebook
     * <br>Creates mapping of number => encoding and initializes <code>number_to_encoding_dict</code>
     * @param codebook_imported_data Parsed codebook data (from csv file)
     */
    public static void init_codebook_from_imported_codebook (String[] codebook_imported_data) {
        for (int i = 2; i < codebook_imported_data.length; i+=2) {
            number_to_encoding_dict.put(codebook_imported_data[i], codebook_imported_data[i+1]);
        }
    }

    /**
     * This function is used to make differences in frequencies significant.
     * It greatly increases frequency of most frequent ones.
     * It also adds (as last step) +1 to all frequencies so that every number has to be encoded
     * @param numbers_frequencies Integer array recording frequencies of numbers
     * @return numbers_frequencies Input array with differences between frequencies made more significant
     */
    public static int[] make_frequencies_significant(int[] numbers_frequencies) {
        for (int i=0 ; i<numbers_frequencies.length; i++) {
            int previous_value = numbers_frequencies[i];
            numbers_frequencies[i] = previous_value * HuffmanCode.FREQUENCY_SIGNIFICANCE_MULTIPLIER + 1;
        }
        return numbers_frequencies;
    }

    /**
     * Uses <code>number_to_encoding_dict</code> mapping of numbers and their encodings and creates csv file with
     * 2 columns, one for numbers and the other for their respective encodings
     */
    public static void export_codebook() {
        String to_export = "Original," + append_spaces("Encoded", 14);
        for (Map.Entry<String, String> entrySet : number_to_encoding_dict.entrySet()) {
            String key = entrySet.getKey();
            String value = entrySet.getValue();
            to_export += "\n" + key + "," + value;
        }
        String[] export = to_export.split(",");
        MyUtils.write_CSV("../test files/codebook", export);
    }

    /**
     * Uses <code>get_huffman_encoding</code> method and concatenates encoding of individual
     * elements in given array
     * @param to_encode String[] Array to encode using Huffman
     * @return
     */
    public static String get_full_huffman_encoding(String[] to_encode) {
        String encoded = "";
        for(String element : to_encode) {
            encoded += get_huffman_encoding(element);
        }
        return encoded;
    }

    /**
     * Prints information regarding Huffman compression results.
     * Prints Full compressed string and ratio (with respect to original/uncompressed string)
     * @param input_array
     * @param overall_uncompressed
     */
    static void print_Huffman_compression_results(String[] input_array, String overall_uncompressed) {
        String compressed = get_full_huffman_encoding(input_array);
        double compression_rate = compression_rate(compressed, overall_uncompressed);
        System.out.println("Huffman compressed: " + compressed);
        System.out.println("Huffman Original/Compressed: " + compression_rate);
    }

    /**
     * WARNING: returns "" if string is not long enough
     * Uses static <code>parameters</code> variable and return substring of input.
     * Returns last <code>parameters[2]</code> digits (represented as String) of input
     * @param binary_input String input of length 12
     * @return Last <code>parameters[2]</code> digits of input
     */
    static String get_LS_nibble(String binary_input) {
        if (binary_input.length() > 11) return binary_input.substring(parameters[0] + parameters[1], 12);
        else {System.out.println("NO LS NIBBLE FOUND"); return "";}
    }

    /**
     * WARNING: returns "" if string is not long enough
     * Uses static <code>parameters</code> variable and return substring of input.
     * Returns middle <code>parameters[1]</code> digits (represented as String) of input
     * @param binary_input String input of length 12
     * @return Input string without first <code>parameters[0]</code> digits and last <code>parameters[2]</code> digits of input
     */
    static String get_middle_nibble(String binary_input) {
        if (binary_input.length() > (11 - parameters[2])) return binary_input.substring(parameters[0], parameters[0] + parameters[1]);
        else {System.out.println("NO MIDDLE NIBBLE FOUND"); return "";}
    }

    /**
     * ASSUMES input is of length 12
     * Uses static <code>parameters</code> variable and return substring of input.
     * Returns middle <code>parameters[1]</code> digits (represented as String) of input
     * @param binary_input String input of length 12
     * @return First <code>parameters[0]</code> digits of input string
     */
    static String get_MS_nibble(String binary_input) {
        return binary_input.substring(0, parameters[0]);
    }

    /**
     * Converts a number in decimal into SIGNED binary number
     *
     * @param decimal_n String decimal number
     * @return SIGNED binary number corresponding to decimal input
     */
    static String decimal_to_binary(String decimal_n) {
        Integer dec_int = Integer.valueOf(decimal_n);
        String binary_repr = Integer.toBinaryString(dec_int);
        if (binary_repr.length()>12) binary_repr = binary_repr.substring(binary_repr.length()-12,binary_repr.length());
        else binary_repr = MyUtils.binary_to_12_bits(binary_repr);
        return binary_repr;
    }

    /**
     * Converts SIGNED binary number into its equivalent decimal number
     * @param binary_n String representation of binary number
     * @return Decimal value of input string
     */
    static String binary_to_decimal(String binary_n) {
        String first_bit = binary_n.substring(0,1); // "1" means number is negative
        Integer decimal_val = Integer.parseInt(binary_n, 2);
        if ("1".equals(first_bit)) {
            decimal_val -= 4096;
        }
        return String.valueOf(decimal_val);
    }

    /**
     * Prepends spaces (if needed) to <code>binary_input</code> to achieve length of 12 bits
     * If input has 12 bit, no action performed
     * @param binary_input original binary string
     * @return Original string with appended spaces (if applicable)
     */
    public static String binary_to_12_bits(String binary_input) {
        int cur_length = binary_input.length();
        if (cur_length < 12) {
            for(int i = cur_length; i < 12; i++) {
                binary_input = "0" + binary_input;
            }
        }
        return binary_input;
    }

    /**
     * Adds a constant to every element of array.
     * Can be used to add/subtract a constant value from all elements of the array
     * @param input_array Input array
     * @param constant Number to sum with each individual element of <code>input_array</code>
     * @return <code>input_array</code> with every element summed by <code>constant</code>
     */
    public static String[] add_to_string_array(String[] input_array, int constant) {
        for(int i=0; i< input_array.length;i++){
            int prev_val = Integer.valueOf(input_array[i]);
            int new_val = prev_val + constant;
            input_array[i] = String.valueOf(new_val);
        }
        return input_array;
    }

    /**
     * Produces number of zeroes based on input
     * @param total_number number of zeroes to output
     * @return <code>total_number</code> of zeroes as String
     */
    public static String generate_zeroes(int total_number) {
        String to_return = new String(new char[total_number]).replace("\0", "0");
        return to_return;
    }

}
